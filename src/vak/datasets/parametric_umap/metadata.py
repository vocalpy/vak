"""A dataclass that represents metadata
associated with a parametric UMAP dataset.

The metadata is generated by
:func:`vak.core.prep.parametric_umap.prep_parametric_umap_dataset`."""
from __future__ import annotations

import json
import pathlib
from typing import ClassVar

import attr

from .. import validators


@attr.define
class Metadata:
    """A dataclass that represents metadata
    associated with a parametric UMAP dataset.

    The metadata is generated by
    :func:`vak.core.prep.parametric_umap.prep_parametric_umap_dataset`.

    Attributes
    ----------
    dataset_csv_filename : str
        Name of csv file representing the source files in the dataset.
        Csv file will be located in root of directory representing dataset,
        so only the filename is given.
    shape : tuple
        Of ints, the shape of the samples.
    audio_format : str
        The format of the source audio files used to generate the dataset.
    """

    # declare this as a constant to avoid
    # needing to remember this in multiple places, and to use in unit tests
    METADATA_JSON_FILENAME: ClassVar = "metadata.json"

    dataset_csv_filename: str = attr.field(
        converter=str, validator=validators.is_valid_dataset_csv_filename
    )

    shape: tuple = attr.field(converter=tuple)

    @shape.validator
    def is_valid_shape(self, attribute, value):
        if not isinstance(value, tuple):
            raise TypeError(
                f"`shape` should be a tuple but type was: {type(value)}"
            )
        if not all([isinstance(val, int) and val > 0 for val in value]):
            raise ValueError(
                f"All values of `shape` should be positive integers but values were: {value}"
            )

    audio_format: str = attr.field(
        converter=attr.converters.optional(str),
        validator=attr.validators.optional(validators.is_valid_audio_format),
        default=None,
    )

    @classmethod
    def from_path(cls, json_path: str | pathlib.Path):
        """Load dataset metadata from a json file.

        Class method that returns an instance of
        :class:`~vak.datasets.parametric_umap.Metadata`.

        Parameters
        ----------
        json_path : string, pathlib.Path
            Path to a 'metadata.json' file created by
            :func:`vak.core.prep.prep` when generating
            a dataset.

        Returns
        -------
        metadata : vak.datasets.parametric_umap.Metadata
            Instance of :class:`~vak.datasets.parametric_umap.Metadata`
            with metadata loaded from json file.
        """
        json_path = pathlib.Path(json_path)
        with json_path.open("r") as fp:
            metadata_json = json.load(fp)
        return cls(**metadata_json)

    @classmethod
    def from_dataset_path(cls, dataset_path: str | pathlib.Path):
        dataset_path = pathlib.Path(dataset_path)
        if not dataset_path.exists() or not dataset_path.is_dir():
            raise NotADirectoryError(
                f"`dataset_path` not found or not recognized as a directory: {dataset_path}"
            )

        metadata_json_path = dataset_path / cls.METADATA_JSON_FILENAME
        if not metadata_json_path.exists():
            raise FileNotFoundError(
                f"Metadata file not found: {metadata_json_path}"
            )

        return cls.from_path(metadata_json_path)

    def to_json(self, dataset_path: str | pathlib.Path) -> None:
        """Dump dataset metadata to a json file.

        This method is called by :func:`vak.core.prep.prep`
        after it generates a dataset and then creates an
        instance of :class:`~vak.datasets.parametric_umap.Metadata`
        with metadata about that dataset.

        Parameters
        ----------
        dataset_path : string, pathlib.Path
            Path where 'metadata.json' file
            should be saved.
            Typically the root of a directory representing a dataset
            generated by
            :func:`vak.core.prep.parametric_umap.prep_parametric_umap_dataset`
        """
        dataset_path = pathlib.Path(dataset_path)
        if not dataset_path.exists() or not dataset_path.is_dir():
            raise NotADirectoryError(
                f"dataset_path not recognized as a directory: {dataset_path}"
            )

        json_dict = attr.asdict(self)
        json_path = dataset_path / self.METADATA_JSON_FILENAME
        with json_path.open("w") as fp:
            json.dump(json_dict, fp, indent=4)
